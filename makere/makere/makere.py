from .helper import (
    contiguous_to_plus,
    generate_pattern_from_letter,
    union,
    concat
)
from .reader import Reader

class Makere:
# words refer to the list of strings that is received from reader
    def __init__(self, words, stemsize = 2):
        self.words = Reader(words).read()
        self.stemsize = stemsize
        self.processedWords = self._to_lists()

    def _find_stem(self):
        
        # Determine size of the array 
        n = len(self.words) 
    
        # Take first word from array  
        # as reference 
        s = self.words[0] 
        l = len(s) 
    
        res = []
    
        for i in range(l) : 
            for j in range( i + 1, l + 1) : 
    
                # generating all possible substrings 
                # of our reference string arr[0] i.e s 
                stem = s[i:j] 
                k = 1
                for k in range(1, n):  
    
                    # Check if the generated stem is 
                    # common to to all words 
                    if stem not in self.words[k]: 
                        break
                
                    # If current substring is present in 
                    # all strings and its length is greater  
                    # than current result
                    avgLen = 0 
                    if k + 1 == n and len(stem) > max((avgLen/2),self.stemsize): 
                        subOfSub = False
                        if len(stem) > avgLen:
                            rmv =[]
                            for sub in res:
                                if stem in sub:
                                    subOfSub = True
                                    break
                                if sub in stem:
                                    totLen = avgLen * len(res)
                                    rmv.append(sub)
                                    try:
                                        avgLen = (totLen - len(sub))/len(res)
                                    except:
                                        avgLen = 0

                        for sub in rmv:
                            res.remove(sub)
                        if not subOfSub:
                            res.append(stem)
                            avgLen = (avgLen + len(stem))/2                
        return res 

    # to_list will convert words from string type into ordered list of letters and stems which were generated by findstem
    def _to_lists(self):
        stems = self._find_stem()
        processedWords = []
        for word in self.words:
            locs = []
            for stem in stems:
                start = word.find(stem)
                end = start + len(stem) 
                locs.append((start,end))

            processedWord =[]
            last = 0
            for loc in sorted(locs):
                if loc[0] > 0:
                    processedWord.append(list(word[last:loc[0]]))
                processedWord.append((word[loc[0]:loc[1]]))
                last = loc[1]                

            processedWord.append(list(word[last::])) 

            processedWords.append(processedWord)
        return processedWords

    def _compress(self):
        for i in range(len(self.processedWords)) :
            for j in range(len(self.processedWords[i])):
                subStrLst = self.processedWords[i][j]
                l = len(subStrLst)        
                if isinstance(subStrLst, list) and l > 1:
                    l = len(subStrLst)                
                    for k in range(l):
                        self.processedWords[i][j][k]= generate_pattern_from_letter(self.processedWords[i][j][k])

                    self.processedWords[i][j] = contiguous_to_plus(self.processedWords[i][j])




    def make(self):
        self._compress()
        #return self.processedWords

        master = self.processedWords[0]
        lenMaster = len(master)
        for cw in range(1, len(self.processedWords)):
            lenCurrent = len(self.processedWords[cw])
            if lenMaster == lenCurrent:
                for i in range(lenMaster):
                    if isinstance(master[i], list) and isinstance(self.processedWords[cw][i], list):
                        master[i] = union(master[i], self.processedWords[cw][i])
                    else:
                        pass
                        #raise TypeError("types to merge not match \nmaster:{} \ncurrent{}".format(master[i], self.processedWords[cw][i]))
            else:
                raise Exception ("Not Yet Handled")

        res = concat(master)
        return res
            




